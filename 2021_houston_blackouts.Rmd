---
title: 'Geospatial analysis of 2021 blackouts in Houston, Texas'
author: "Kristin Art"
date: "2022-10-26"
output:   
  html_document:
    code_folding: hide
---

```{r setup, echo = TRUE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(ggplot2)
library(sf)
library(stars)
library(spData)
library(ggspatial)
library(patchwork)
```

### Introduction

The purpose of this script is to analyze the impact of winter storms in 2021 on the Houston, Texas area. I investigate the number of homes in Houston that lost power as a result of two storms that occurred on February 10–11 and 13–17. Then, I investigate whether socioeconomic factors are predictors of a community's recovery from a power outage. 

### Methods

1) First, I identify the location of blackouts in the Houston area by combining satellite images from before (Feb 7, 2021) and after (Feb 16, 2021) the storms. I assumed that any location that experienced a drop of more than $200 nW cm^{-2} sr^{-1}$ between the two dates experienced a blackout. I also excluded the area 200m around major highways to minimize falsely identifying areas with reduced traffic as areas without power since highways are responsible for a large proportion of night lights seen from space.  
    
```{r}
# load night light tiles 
h08v05_20210207 <- stars::read_stars(here::here("data/VNP46A1/VNP46A1.A2021038.h08v05.001.2021039064328.tif"))

h08v06_20210207 <- stars::read_stars(here::here("data/VNP46A1/VNP46A1.A2021038.h08v06.001.2021039064329.tif"))

h08v05_20210216 <- stars::read_stars(here::here("data/VNP46A1/VNP46A1.A2021047.h08v05.001.2021048091106.tif"))

h08v06_20210216 <- stars::read_stars(here::here("data/VNP46A1/VNP46A1.A2021047.h08v06.001.2021048091105.tif"))

# combine tiles for each date
feb7 <- stars::st_mosaic(h08v05_20210207, h08v06_20210207)
feb16 <- stars::st_mosaic(h08v05_20210216, h08v06_20210216)
```

```{r eval = FALSE}
# exploratory plots
plot(h08v05_20210207)
plot(h08v06_20210207)
plot(feb7)
```

```{r}
# find the difference in light intensity before/ after the storm and only select the differences > 200, turn areas less than or equal to 200 to NAs
lights_diff <- (feb7 - feb16)
lights_diff[lights_diff <= 200] = NA
```

```{r eval = FALSE}
# exploratory plots/ checks
lights_diff

plot(feb7)
plot(feb16)
plot(lights_diff)
```

```{r}
# vectorize the mask, fix any invalid geometries
blackout_mask <- lights_diff %>%
  sf::st_as_sf() %>%
  sf::st_make_valid()
```

```{r eval = FALSE}
# exploratory plots/ checks
plot(blackout_mask)
attributes(blackout_mask)
blackout_mask
```

```{r}
#create a polygon for the houston area manually using known coordinates
houston_polygon <- sf::st_polygon(list(rbind(c(-96.5, 29), 
                                             c(-96.5, 30.5), 
                                             c(-94.5, 30.5), 
                                             c(-94.5, 29), 
                                             c(-96.5, 29))))

# set houston sf crs to crs of blackout/ night lights data
houston_sf <- sf::st_sfc(houston_polygon, crs = sf::st_crs(blackout_mask))

# test that crs match
ifelse(sf::st_crs(houston_sf) == sf::st_crs(blackout_mask), (print("TRUE, CRS of both sf objects match")), (print("FALSE, check that CRS of both sf objects match")))

# crop blackout mask using houston sf
blackout_crop <- sf::st_intersection(blackout_mask, houston_sf)

# test that new object has fewer values
ifelse(nrow(blackout_crop) < nrow(blackout_mask), (print(paste0("TRUE, cropped object has ", (nrow(blackout_mask) - nrow(blackout_crop)), " fewer values than original"))), (print("FALSE, cropped object does not have fewer values than original")))

# reproject to EPSG 3083
blackout_crop_3083 <- sf::st_transform(blackout_crop, crs = "EPSG:3083")
```

```{r eval = FALSE}
# exploratory plots/checks
sf::st_crs(blackout_crop_3083)
plot(blackout_crop_3083)
```

```{r}
# load highways data using SQL query
query <- "SELECT * FROM gis_osm_roads_free_1 WHERE fclass='motorway'"
highways <- sf::st_read(here::here("data/gis_osm_roads_free_1.gpkg"), query = query, quiet = TRUE)

# reproject to EPSG 3083
highways_3083 <- sf::st_transform(highways, crs = "EPSG:3083")

# create dissolved buffers
highways_200mbuffer <- sf::st_buffer(highways_3083, dist = 200) %>% # EPSG 3083 is projected in meters, so distance units are meters
  sf::st_union()
```

```{r eval = FALSE}
# exploratory plots
plot(highways_200mbuffer)
class(highways_200mbuffer)
```

```{r}
# test that crs match
ifelse(sf::st_crs(highways_200mbuffer) == sf::st_crs(blackout_crop_3083), (print("TRUE, CRS of both sf objects match")), (print("FALSE, check that CRS of both sf objects match")))

# find intersection between blackout data and buffered highways
blackout_highways_intersection <- sf::st_filter(blackout_crop_3083, highways_200mbuffer, join = st_intersection())

# find the difference between blackout data and the blackout/ highways intersection
blackout_highways <- sf::st_difference(blackout_crop_3083, sf::st_union(sf::st_geometry(blackout_highways_intersection)))

# test that length of new blackout mask is shorter than length of old blackout mask
ifelse(nrow(blackout_highways) < nrow(blackout_crop_3083), (print(paste0("TRUE, new sf object is shorter than old sf object by ", (nrow(blackout_crop_3083) - nrow(blackout_highways)), " rows"))), (print("FALSE, new sf object is NOT shorter than old sf object, check crop methods")))

# test that the length of the new object is equivalent to the difference of the full blackout data and the highway buffer data
ifelse(((nrow(blackout_crop_3083) - nrow(blackout_highways_intersection)) == nrow(blackout_highways)), (print("TRUE, the length of the new blackout mask is equal to the difference between the old blackout mask and the intersection between the blackout mask and highway buffers")), (print("FALSE, the length of the new blackout mask is NOT equal to the difference between the old blackout mask and the intersection between the blackout mask and highway buffers, check exclusion methods")))

# test that all values in the new blackout mask are unique
ifelse(nrow(unique(blackout_highways)) == nrow((blackout_highways)), (print("TRUE, all values in new sf object are unique")), (print("FALSE, not all values in new sf object are unique")))
```


```{r eval = FALSE}
# exploratory plots
plot(blackout_highways)
plot(blackout_crop)
plot(highways_200mbuffer)
```

2) Next, I identify homes that were impacted by blackouts by geospatially combining the blackout mask I created with building locations.

```{r}
# load buildings data using SQL query
query <- "SELECT *FROM gis_osm_buildings_a_free_1 WHERE (type IS NULL AND name IS NULL) OR type in ('residential', 'apartments', 'house', 'static_caravan', 'detached')"
buildings <- sf::st_read(here::here("data/gis_osm_buildings_a_free_1.gpkg"), query = query, quiet = TRUE)

# reproject to crs epsg 3083
buildings_3083 <- sf::st_transform(buildings, crs = "EPSG:3083")

# test that crs match
ifelse(sf::st_crs(buildings_3083) == sf::st_crs(blackout_highways), (print("TRUE, CRS of both sf objects match")), (print("FALSE, check that CRS of both sf objects match")))

# find the homes that are within blackout areas
blackout_homes <- sf::st_filter(buildings_3083, blackout_highways, join = st_within()) %>%
  dplyr::select("osm_id", "fclass", "geom") %>%
  st_make_valid()

#count the homes that are within blackout areas
blackout_homes_logical <- nrow(blackout_homes)
n <- sum(nrow(blackout_homes))

print(paste0("The number of homes within the blackout area is ", n, ", which is ", round(100 * n / nrow(buildings_3083)), "% of all buildings in the area"))
```

3) Finally, I identify which census tracts in the Houston area were impacted by blackouts by geospatially combining the census tracts with the building locations that experienced blackouts. I investigate the median income of each census tract and compare the distributions between tracts that did and did not experience a blackout. 

Results indicate that the blackouts impacted slightly more homes in census tracts with higher median incomes than those with lower median incomes (Figure 2, Figure 3). However, this study did not take population and infrastructure into account. Tracts with higher median incomes could potentially have larger populations and therefore use more light in general. Comparatively, homes in tracts with lower median incomes could generally use less light in an effort to use less electricity and save money. Therefore, the metric we used to define a blackout for this study (based on a $200 nW cm^{-2} sr^{-1}$ drop in light intensity between two satellite images) could be introducing bias. 

```{r}
# load in ACS data
socioeconomic_geom <- sf::st_read(here::here("data/ACS_2019_5YR_TRACT_48_TEXAS.gdb"), layer = "ACS_2019_5YR_TRACT_48_TEXAS", quiet = TRUE)

income <- sf::st_read(here::here("data/ACS_2019_5YR_TRACT_48_TEXAS.gdb"), layer = "X19_INCOME", quiet = TRUE) %>% 
  dplyr::select("GEOID", "B19013e1") %>%
  rename("INCOME" = "B19013e1")

# combine layers based on GEOID, convert to sf object
socioeconomic <- socioeconomic_geom %>%
  dplyr::select("Shape_Length", "Shape_Area", "GEOID_Data", "Shape") %>%
  rename("GEOID" = "GEOID_Data") %>%
  full_join(income, by = "GEOID") %>%
  janitor::clean_names()

# reproject to crs epsg 3083
socioeconomic_3083 <- sf::st_transform(socioeconomic, crs = "EPSG:3083")
houston_3083 <- sf::st_transform(houston_sf, crs = "EPSG:3083")

# crop tracts data to houston area
tracts_houston <- sf::st_crop(socioeconomic_3083, houston_3083)

# test that crs match
ifelse(sf::st_crs(socioeconomic_3083) == sf::st_crs(blackout_homes), (print("TRUE, CRS of both sf objects match")), (print("FALSE, check that CRS of both sf objects match")))

# spatially join census tract data to buildings data
tracts_buildings <- sf::st_join(socioeconomic_3083, blackout_homes, join = st_contains, largest = TRUE)

# filter to only tracts that had buildings that experienced blackouts
tracts_blackouts <- tracts_buildings %>%
  filter(fclass == "building")
```


```{r plot_3, out.width="100%", fig.align = 'center', fig.cap = "**Figure 1: Census tracts in Houston, Texas, that experienced a blackout.** Blue shading denotes census tracts that experienced a blackout while grey shading represents census tracts that did not. The inset map displays the location of the bounding box of Houston relative to the boundary of Texas. "}
# load shape of texas
tx <- us_states %>%
  janitor::clean_names() %>%
  filter(name == "Texas") %>%
  st_transform(crs = "EPSG:3083")

# plot which tracts experienced blackouts
plot_1 <- ggplot() +
  geom_sf(data = tracts_houston) +
  geom_sf(data = tracts_blackouts, aes(fill = ""), show.legend = TRUE) +
  scale_fill_manual(name = "Experienced \nblackout", values = "#3B9AB2") +
  annotation_scale(plot_unit = "km", location = "bl", pad_x = unit(2.2, "in"), style = "ticks") +
  annotation_north_arrow(
    location = "bl",
    pad_x = unit(4.45, "in"),
    pad_y = unit(0.95, "in"),
    style = ggspatial::north_arrow_nautical()
  ) +
  theme_bw() +
  theme(legend.position = "right")

# create plot of texas
plot_2 <- ggplot() +
  geom_sf(data = tx, col = "black", fill = "white") +
  geom_sf(data = houston_sf, fill = "grey20") +
  theme_bw() +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# combine plot and texas inset
plot_3 <- plot_1 + inset_element(plot_2, 0.78, 0.002, 0.99, 0.2)

plot_3
```

```{r plot_5, out.width="100%", fig.align = 'center', fig.cap = "**Figure 2: Median income of census tracts in Houston, Texas** Grey lines represent boundaries of census tracts and color shading indicates median income of each tract. Black dots denote census tracts that experienced blackouts. The inset map displays the location of the bounding box of Houston relative to the boundary of Texas."}
# create centroids for tracts with blackouts
tracts_blackouts_centroids <- sf::st_centroid(tracts_blackouts)

# plot median income by census tracts
plot_4 <- ggplot() +
  geom_sf(data = tracts_houston, aes(fill = income)) +
  scale_fill_viridis_c() +
  labs(fill = "Median Income ($)") +
  geom_sf(data = tracts_blackouts_centroids, size = 0.5, aes(color = "")) +
  scale_colour_manual(name = "Experienced \nblackout", values = "black") +
  annotation_scale(plot_unit = "km", location = "bl", pad_x = unit(2.1, "in"), pad_y = unit(0.008, "in"), style = "ticks") +
  annotation_north_arrow(
    location = "bl",
    pad_x = unit(4.1, "in"),
    pad_y = unit(0.8, "in"),
    style = ggspatial::north_arrow_nautical()
  ) +
  theme_bw()

# combine plot and texas inset
plot_5 <- plot_4 + inset_element(plot_2, 0.78, 0.002, 0.99, 0.2)

plot_5
```


```{r plot_8, out.width="100%", fig.align = 'center', fig.cap = "**Figure 3: Distribution of median income between census tracts in Houston that did and did not experience blackouts.** A) Box and whisker plot depicting the distribution of median income within tracts that experienced blackouts (blue) and those that did not (yellow). Black line represents median income value, lower hinge represents the first quartile, upper hinge represents the third quartile, whiskers represent upper and lower range up to 1.5 times the interquartile range, and dots represent outliers. B) Density plot depicting the distribution of median income within tracts that experienced blackouts (blue) and those that did not (yellow)."}
# select income column only for blackout tracts
income_blackouts <- tracts_blackouts %>%
  dplyr::select(income) %>%
  st_drop_geometry()

# select income column for non-blackout tracts
income_no_blackouts <- tracts_buildings %>%
  filter(is.na(fclass)) %>%
  dplyr::select(income) %>%
  st_drop_geometry()

# combine income data
income_distr <- rbind(cbind(income_blackouts, group = "Blackouts"), cbind(income_no_blackouts, group = "No blackouts"))

# plot income distribution
plot_6 <- ggplot(income_distr) +
  geom_boxplot(aes(x = group, y = income, fill = group), notch = TRUE) +
  scale_fill_manual(values = c("#3B9AB2", "#EBCC2A")) +
  labs(x = "Tract type", y = "Income ($)", fill = "Tract type") +
  theme_bw() +
  theme(legend.position = "none")

plot_7 <- ggplot(income_distr) +
  geom_density(aes(x = income, col = group), size = 1.5) +
  labs(col = "Tract type", x = "Income ($)", y = "Density") +
  scale_color_manual(values = c("#3B9AB2", "#EBCC2A")) +
  theme_bw() +
  theme(legend.position = "bottom")

plot_8 <- (plot_6 + plot_layout(guides = "collect") & theme(legend.position = "bottom")) + (plot_7 + theme(legend.position = "none")) + plot_annotation(tag_levels = "A")

plot_8
```
